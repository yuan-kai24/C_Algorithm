#include <stdio.h>
int main() {
	int n,i = 0,sum = 0,sum2 = 0;
	scanf("%d",&n);
	while(sum2 < n)
	{
		i++;
		sum2 += sum+1;
		sum += i;	
	}
	printf("%d",i);
	return 0;
}


/*
采用贪心思想，局部最优解
当只有一部手机时n层楼就要摔n次
当有两部手机时就可以拿一部手机减少一次步数摔定位，定位在（n-1）+1-->[也就是n]层摔一次，然后在n+n-1摔，n+n-1+n-2..得出结论是n的累加
减少一次步数摔定位问题：留下的那一步是用来定位的，所以定位后加了1
然后很容易推出：
既然有三部手机，那就可以先拿两部手机摔出定位,定位在<n的累加>(两部手机的算法)+1处摔，就是又一次对两部手机的累加
这样，是用步数推出最大能摔的层数
然后判断(最大能摔的层数 < 需要的层数)取出所需步数就可以得出结果
*/